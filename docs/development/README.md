# Development Guide

## Getting Started

### Prerequisites

- Node.js 18+ (required for ES2022 features)
- pnpm 8+ (required, enforced via preinstall hook)
- Chrome 140+ (for built-in AI APIs)

### Quick Setup

```bash
# Clone and install
git clone <repository-url>
cd language-learning-extension
pnpm install

# Initialize git hooks (sets up Husky pre-commit hooks)
pnpm prepare

# Start development (TypeScript watch mode)
pnpm dev
```

## Development Workflow

### Daily Commands

```bash
# Development
pnpm dev              # TypeScript watch mode compilation
pnpm build            # Production build (TypeScript + asset copying)
pnpm copy-assets      # Copy static assets to dist/

# Code Quality
pnpm lint             # Oxlint (fast) checking
pnpm lint:fix         # Auto-fix linting issues
pnpm lint:eslint      # ESLint alternative checking
pnpm lint:eslint:fix  # ESLint auto-fix
pnpm lint:manifest    # Prettier check for manifest.json
pnpm lint:extension   # Combined linting (Oxlint + manifest)
pnpm format           # Prettier formatting for all files
pnpm format:check     # Check formatting without fixing
pnpm type-check       # TypeScript validation without compilation

# Testing
pnpm test             # Run all tests once (Vitest)
pnpm test:watch       # Watch mode testing
pnpm test:coverage    # Coverage reports with V8 provider
pnpm test:ui          # Vitest UI interface

# Extension Validation
pnpm validate:extension  # Full pipeline: lint + test + build
pnpm lint:switch      # Switch between Oxlint and ESLint
```

### Code Quality Automation

#### Pre-commit Hooks

Every commit automatically runs:

1. Prettier formats staged files
2. Oxlint checks and fixes issues
3. Commit proceeds if no errors

#### Linting Strategy

- **Oxlint (Default)**: Fast Rust-based linting for development
  - Configuration: `oxlint.json` with TypeScript, correctness, and performance rules
  - Globals: Chrome extension APIs, browser APIs, ES2022 environment
  - Ignores: `dist/`, `node_modules/`, config files, scripts
- **ESLint (Alternative)**: Comprehensive analysis for CI/CD
  - Configuration: `eslint.config.js` with context-specific rules
  - TypeScript support with `@typescript-eslint` plugin
  - Context-aware rules for background, content, offscreen, and UI components
  - Import ordering and Prettier integration
- **Switch between linters**: `pnpm run lint:switch --oxlint|--eslint`
  - Automatically updates `package.json` scripts and `lint-staged` configuration
  - Runs the selected linter after switching

## Project Structure

```
src/
├── background/           # Service worker (no DOM access)
│   └── service-worker.ts # Main background script
├── content/              # Content scripts (DOM interaction)
│   └── content-script.ts # Page content interaction
├── offscreen/            # Offscreen documents (AI processing)
│   ├── ai-processor.ts   # AI processing logic
│   └── ai-processor.html # Offscreen document HTML
├── ui/                   # User interface components
│   ├── learning-interface.* # Main learning UI
│   ├── settings.*        # Settings interface
│   ├── setup-wizard.*    # Initial setup flow
│   └── highlight-manager.ts # Text highlighting logic
├── types/                # TypeScript type definitions (centralized)
│   └── index.ts          # All interface definitions
└── utils/                # Shared utilities (single-responsibility)
    ├── ai-service-coordinator.ts # AI service orchestration
    ├── article-processor.ts      # Article content processing
    ├── batch-processor.ts        # Batch processing utilities
    ├── cache-manager.ts          # Caching system
    ├── chrome-ai.ts              # Chrome Built-in AI APIs
    ├── content-extraction.ts     # Content extraction pipeline
    ├── data-migrator.ts          # Data migration utilities
    ├── error-handler.ts          # Centralized error handling
    ├── gemini-api.ts             # Gemini API integration
    ├── import-export.ts          # Data import/export
    ├── memory-manager.ts         # Memory optimization
    ├── offline-handler.ts        # Offline functionality
    ├── offscreen-manager.ts      # Offscreen document management
    ├── progress-tracker.ts       # Progress tracking
    ├── storage-manager.ts        # Data persistence
    └── tts-service.ts            # Text-to-speech

tests/                    # Test files with comprehensive coverage
├── setup/                # Test configuration and mocking
│   └── chrome-mock.ts    # Chrome API mocking utilities
├── setup.ts              # Global test setup
├── *.test.ts             # Unit and integration tests
├── integration.test.ts   # Cross-component integration
├── user-acceptance.test.ts # End-to-end user workflows
└── system-integration.test.ts # System-wide integration

dist/                     # Compiled output (generated by build)
docs/                     # Documentation
.kiro/                    # Kiro IDE configuration and specs
scripts/                  # Build and utility scripts
├── copy-assets.js        # Asset copying for build
└── lint-switcher.js      # Linter switching utility
```

### Architecture Principles

- **Separation of Concerns**: Each directory has specific responsibility
- **Centralized Types**: All TypeScript interfaces in `src/types/index.ts`
- **Utility-First**: Shared logic in `src/utils/` with single-responsibility
- **Chrome Extension Boundaries**: Respect service worker vs content script limitations

## Chrome Extension Development

### Context-Specific Rules

- **Service Worker** (`background/`): No DOM access, Chrome APIs only
- **Content Scripts** (`content/`): Full DOM access + Chrome messaging
- **Offscreen Documents** (`offscreen/`): DOM + specific Chrome APIs
- **UI Components** (`ui/`): Full DOM access + Chrome extension APIs

### Message Passing

Use typed message interfaces for inter-component communication:

```typescript
// Define in src/types/index.ts
interface ExtractContentMessage {
  type: 'EXTRACT_CONTENT';
  url: string;
}

// Use in components
chrome.runtime.sendMessage<ExtractContentMessage>({
  type: 'EXTRACT_CONTENT',
  url: window.location.href,
});
```

### Storage Patterns

- **Versioned Schema**: Include version tracking for migrations
- **Session vs Local**: Temporary data in session, persistent in local
- **Cache Management**: Automatic cleanup when approaching limits

## Testing Strategy

### Test Structure

```
tests/
├── setup.ts                        # Global test configuration (Vitest + jsdom)
├── setup/
│   └── chrome-mock.ts              # Chrome API mocking utilities
├── ai-fallback.test.ts             # AI service fallback testing
├── batch-processor-integration.test.ts # Batch processing integration
├── cache-manager.test.ts           # Cache system unit tests
├── cache-manager-edge-cases.test.ts # Cache edge cases
├── cache-performance-benchmark.test.ts # Performance benchmarks
├── chrome-ai.test.ts               # Chrome AI API integration
├── content-extraction.test.ts      # Content extraction pipeline
├── content-script.test.ts          # Content script functionality
├── cross-component-integration.test.ts # Cross-component integration
├── error-handling.test.ts          # Error handling systems
├── error-scenarios.test.ts         # Error scenario testing
├── integration.test.ts             # General integration tests
├── manifest.test.ts                # Manifest validation
├── memory-management.test.ts       # Memory optimization tests
├── performance.test.ts             # Performance testing
├── service-worker.test.ts          # Background script testing
├── settings-system.test.ts         # Settings management
├── storage-system.test.ts          # Storage system tests
├── system-integration.test.ts      # System-wide integration
├── tts-service.test.ts             # Text-to-speech testing
├── ui-components.test.ts           # UI component testing
└── user-acceptance.test.ts         # End-to-end user workflows
```

### Test Categories

- **Unit Tests**: Individual component functionality (cache-manager, chrome-ai, etc.)
- **Integration Tests**: Component interaction and data flow (cross-component, batch-processor)
- **Performance Tests**: Benchmarking and optimization validation
- **Edge Case Tests**: Boundary conditions and error scenarios
- **User Acceptance Tests**: Complete user workflows and acceptance criteria
- **System Tests**: Extension lifecycle, memory management, and system-wide behavior

### Test Framework Configuration

- **Test Runner**: Vitest with jsdom environment
- **Coverage Provider**: V8 with HTML and JSON reports
- **Global Setup**: Chrome API mocking in `tests/setup.ts`
- **Chrome API Mocking**: Comprehensive mocking in `tests/setup/chrome-mock.ts`
- **TypeScript Config**: Separate `tsconfig.test.json` for test-specific settings

### Running Tests

```bash
# All tests (single run)
pnpm test

# Specific test file
pnpm test tests/chrome-ai.test.ts

# Watch mode for development
pnpm test:watch

# Coverage report (HTML + JSON)
pnpm test:coverage

# Interactive UI
pnpm test:ui

# Performance benchmarks
pnpm test tests/cache-performance-benchmark.test.ts
```

## Code Style Guidelines

### TypeScript

- **Strict Mode**: Enabled with explicit return types
- **Named Exports**: Prefer over default exports
- **Type Imports**: Use `import type` for type-only imports
- **No `any`**: Use proper types or `unknown`

### File Naming

- **Kebab-case**: All files use kebab-case (`content-script.ts`)
- **Descriptive Names**: Files clearly indicate purpose
- **Component Grouping**: Related functionality in same directory

### Import/Export Patterns

```typescript
// ✅ Good - named exports
export { CacheManager, getCacheManager };

// ✅ Good - type imports
import type { UserSettings } from './types';

// ✅ Good - relative imports within module
import { validateContent } from './validation';

// ✅ Good - absolute imports for cross-module
import { getCacheManager } from '../utils/cache-manager';
```

## Build System

### TypeScript Compilation

- **Target**: ES2022 with ES2022 modules
- **Output**: `dist/` directory with source maps enabled
- **Type Checking**: Strict mode with Chrome types and `@types/chrome`
- **Configuration**: `tsconfig.json` with strict settings
- **Test Configuration**: Separate `tsconfig.test.json` for test files

### Asset Pipeline (`scripts/copy-assets.js`)

The build process copies static assets from source to distribution:

```javascript
// Assets copied during build:
- manifest.json → dist/manifest.json
- icons/ → dist/icons/ (directory structure)
- src/ui/learning-interface.html → dist/ui/learning-interface.html
- src/ui/learning-interface.css → dist/ui/learning-interface.css
- src/ui/setup-wizard.html → dist/ui/setup-wizard.html
- src/ui/setup-wizard.css → dist/ui/setup-wizard.css
- src/ui/settings.html → dist/ui/settings.html
- src/ui/settings.css → dist/ui/settings.css
- src/offscreen/ai-processor.html → dist/offscreen/ai-processor.html
```

### Build Commands

```bash
# Full build (TypeScript + assets)
pnpm build

# TypeScript compilation only
tsc

# Asset copying only
pnpm copy-assets

# Development build with watch
pnpm dev
```

### Build Output Structure

```
dist/
├── background/
│   └── service-worker.js         # Background script
├── content/
│   └── content-script.js         # Content script
├── offscreen/
│   ├── ai-processor.js           # Offscreen processing
│   └── ai-processor.html         # Offscreen document
├── ui/
│   ├── learning-interface.js     # Learning interface logic
│   ├── learning-interface.html   # Learning interface HTML
│   ├── learning-interface.css    # Learning interface styles
│   ├── settings.js               # Settings logic
│   ├── settings.html             # Settings HTML
│   ├── settings.css              # Settings styles
│   ├── setup-wizard.js           # Setup wizard logic
│   ├── setup-wizard.html         # Setup wizard HTML
│   ├── setup-wizard.css          # Setup wizard styles
│   └── highlight-manager.js      # Highlighting logic
├── types/
│   └── index.js                  # Type definitions (compiled)
├── utils/
│   └── *.js                      # All utility modules
├── icons/                        # Extension icons
└── manifest.json                 # Chrome extension manifest
```

### Build Validation

The `validate:extension` command runs the complete validation pipeline:

1. **Linting**: Oxlint source code + Prettier manifest check
2. **Testing**: Full test suite with coverage
3. **Building**: TypeScript compilation + asset copying
4. **Verification**: Ensures build output is complete and valid

## Debugging

### Chrome Extension Debugging

1. Load `dist/` as unpacked extension
2. Use Chrome DevTools for each context:
   - **Service Worker**: chrome://extensions → Inspect views
   - **Content Script**: Page DevTools → Sources
   - **Offscreen**: chrome://extensions → Inspect views

### Common Issues

- **Service Worker Limitations**: No `window` or `document` access
- **Content Script Context**: Isolated from page scripts
- **Message Passing**: Ensure proper message type definitions
- **Storage Quota**: Monitor usage and implement cleanup

## Contributing

### Pull Request Process

1. Create feature branch from `main`
2. Implement changes with tests
3. Run `pnpm validate:extension`
4. Submit PR with clear description

### Code Review Checklist

- [ ] Tests pass and cover new functionality
- [ ] Code follows style guidelines
- [ ] TypeScript types are properly defined
- [ ] Chrome extension context rules followed
- [ ] Documentation updated if needed

### Commit Messages

Use conventional commits:

```
feat: add vocabulary highlighting system
fix: resolve cache manager export issues
docs: update API documentation
test: add integration tests for AI fallback
```

## Troubleshooting

### Common Development Issues

#### Linting Errors

```bash
# Fix Oxlint issues automatically
pnpm lint:fix

# Switch to ESLint for more detailed analysis
pnpm run lint:switch --eslint

# Clear ESLint cache (if using ESLint)
pnpm exec eslint --clear-cache

# Switch back to Oxlint for faster development
pnpm run lint:switch --oxlint

# Check specific file
pnpm lint src/utils/specific-file.ts
```

#### Test Failures

```bash
# Run specific test file
pnpm test tests/chrome-ai.test.ts

# Run tests matching pattern
pnpm test --grep "cache manager"

# Debug with interactive UI
pnpm test:ui

# Run tests with coverage to identify gaps
pnpm test:coverage

# Watch mode for continuous testing
pnpm test:watch
```

#### Build Issues

```bash
# Clean build (Windows)
rmdir /s /q dist node_modules
pnpm install
pnpm build

# Type checking without compilation
pnpm type-check

# Build assets only
pnpm copy-assets

# Validate entire extension
pnpm validate:extension
```

#### Package Manager Issues

```bash
# Clear pnpm cache
pnpm store prune

# Reinstall dependencies
pnpm install --frozen-lockfile

# Update dependencies
pnpm update
```

#### Chrome Extension Issues

- Check manifest.json syntax
- Verify permissions in Chrome
- Check service worker console for errors
- Ensure content scripts are injected properly

## Related Documentation

- **[Architecture Overview](../architecture/README.md)** - System design and component relationships
- **[API Reference](../api/README.md)** - Chrome AI integration details
- **[Testing Guide](../testing/README.md)** - Test suite and coverage
- **[User Guide](../user-guide/README.md)** - End-user feature documentation

### Getting Help

1. Check this documentation
2. Review test files for usage examples
3. Consult Chrome Extension documentation
4. Check project issues and discussions
